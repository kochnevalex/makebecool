Данная документация подготвленна на основе статьи [Удачная модель ветвления для Git](http://habrahabr.ru/post/106912/)

# Главные ветви
Центральный репозиторий содержит две главные ветки, существующие всё время:
- **master;**
- **develop.**

Ветвь **master** создаётся при инициализации репозитория. Параллельно ей также мы создаём ветку для разработки под названием **develop**.

Мы считаем ветку **origin/master** главной.
То есть, исходный код в ней должен находиться в состоянии production-ready в любой произвольный момент времени.

Ветвь **origin/develop** мы считаем главной ветвью для разработки.
Хранящийся в ней код в любой момент времени должен содержать самые последние изданные изменения, необходимые для следующего релиза.

Когда исходный код в ветви разработки (develop) достигает стабильного состояния и готов к релизу, все изменения должны
быть определённым способом влиты в главную ветвь (master) и помечены тегом с номером релиза. Ниже мы рассмотрим этот процесс в деталях.

# Вспомогательные ветви

Помимо главных ветвей master и develop, наша модель разработки содержит некоторое количество типов вспомогательных ветвей,
которые используются для распараллеливания разработки между членами команды, для упрощения внедрения нового функционала (features),
для подготовки релизов и для быстрого исправления проблем в производственной версии приложения. В отличие от главный ветвей,
эти ветви всегда имеют ограниченный срок жизни. Каждая из них в конечном итоге рано или поздно удаляется.

**Мы используем следующие типы ветвей:**
- Ветви функциональностей (Feature branches)
- Ветви релизов (Release branches)
- Ветви исправлений (Hotfix branches)

## Ветви функциональностей (feature branches)

**IMPORTANT: Могут порождаться от: develop**

**IMPORTANT: Должны вливаться в: develop**

**Соглашение о наименовании: feature-...**

**Пример:** Поступила задача разработать на сайте дополнительное вертикальное меню. Этого функционала в данный момент нет,
 значит эта задача должна быть реализована в ветви функциональностей.

```
1. $ git checkout -b feature-additional_vertical_menu develop // создание ветки feature-additional_vertical_menu от ветки develop и переход в нее
2. /* Работа над задачей*/
3. $ git add .  // добавляем созданные файлы, если они были
4. $ git commit -a -m “[comment]”// комитим изменения в локальный репозиторий
5. $ git checkout develop // по завершении задачи переходим в ветку разработки для того чтобы добавить в нее нашу фичу
6. $ git merge --no-ff feature-additional_vertical_menu // и обьединяем ее с ветвью фич
7. $ git push origin develop // пушим изменения в общий репозиторий для разработки
```
NOTE: Флаг **--no-ff** вынуждает Git всегда создавать новый объект коммита при слиянии, даже если слияние может быть
 осуществлено алгоритмом fast-forward. Это позволяет не терять информацию о том, что ветка существовала, и
 группирует вместе все внесённые изменения.

## Ветви релизов (release branches)

**IMPORTANT: Могут порождаться от: develop**

**IMPORTANT: Должны вливаться в: develop и master**

**Соглашение о наименовании: release-* **

- используются для подготовки к выпуску новых версий продукта
- новую ветку релиза (release branch) надо порождать в тот момент, когда по крайней мере, вся необходимая функциональность, предназначенная к этому релизу, уже влита в ветвь разработки (develop).
- очередной релиз получает свой номер версии только в тот момент, когда для него создаётся новая ветвь, но ни в коем случае не раньше.

**Пример:** Клиент попросил добавить новый функционал по сайту. Задачи были распределены между программистами.
 Каждый из них добавил новый функционал в своей ветке feature, а затем вылил все в ветку develop.
 Когда все задачи сделаны от ветки develop создаем ветку релиза.

```
1. $ git checkout -b release-1.1 develop
2. /* Работа над релизом*/
3. $ git add .  // добавляем созданные файлы, если они были
4. $ git commit -a -m “[comment]”// комитим изменения в локальный репозиторий
```
Мы создали новую ветку, переключились в неё, а затем выставили номер версии.

Эта новая ветвь может существовать ещё некоторое время, до тех пор, пока новый релиз окончательно не будет готов к выпуску.
 В течение этого времени к этой ветви **(а не к develop)** могут быть добавлены исправления найденных багов.
 Но добавление крупных новых изменений в эту ветвь строго запрещено. Они всегда должны вливаться в ветвь разработки (develop) и ждать следующего большого релиза.

### Закрытие ветви релиза
Когда мы решаем, что ветвь релиза окончательно готова для выпуска, нужно проделать несколько действий.
 В первую очередь ветвь релиза вливается в главную ветвь **(напоминаю, каждый коммит в master — это по определению новый релиз)**.
 Далее, этот коммит в master должен быть помечен тегом, чтобы в дальнейшем можно было легко обратиться к любой существовавшей
 версии продукта. И наконец, изменения, сделанные в ветви релиза, должны быть добавлены обратно в
 разработку, чтобы будущие релизы также содержали внесённые исправления багов.

```
1. $ git checkout master
2. $ git merge --no-ff release-1.1
3. $ git tag -a 1.1
4. $ git checkout develop
5. $ git merge --no-ff release-1.1
6. $ git branch -d release-1.1 // удаляем ветку релиза, потому что она нам больше не нужна
```

## Ветви исправлений (hotfix branch)

**IMPORTANT: Могут порождаться от: master**

**IMPORTANT: Должны вливаться в: master и develop**

**IMPORTANT: Если в данный момент активна ветка релиза, то ветку исправлений создавать не нужно, делаем фикс в релизе**

**Соглашение о наименовании: hotfix-...**

**Пример:** Пускай, например, текущий производственный релиз имеет версию 1.1, и в нём (внезапно!) обнаруживается серьёзный баг.
 А изменения в ветви разработки (develop) ещё недостаточно стабильны, чтобы их издавать в новый релиз.
 Но мы можем создать новую ветвь исправлений и начать работать над решением проблемы:

```
1. $ git checkout -b hotfix-1.1.1 master
2. $ git commit -a -m "Bumped version number to 1.1.1"
3. /* Работа над фиксом*/
4. $ git commit -m "Fixed severe production problem"
```

### Закрытие ветви исправлений
Когда баг исправлен, изменения надо влить обратно в главную ветвь (master), а также в ветвь разработки (develop),
 чтобы гарантировать, что это исправление окажется и в следующем релизе. Это очень похоже на то, как закрывается ветвь релиза (release branch).

**IMPORTANT:  Если в данный момент существует ветвь релиза (release branch), то ветвь исправления (hotfix branch) должна
 вливаться в неё, а не в ветвь разработки (develop)**

```
1. $ git checkout master
2. $ git merge --no-ff hotfix-1.1.1
3. $ git tag -a 1.2.1
4. $ git checkout develop
5. $ git merge --no-ff hotfix-1.2.1
6. $ git branch -d hotfix-1.2.1
```