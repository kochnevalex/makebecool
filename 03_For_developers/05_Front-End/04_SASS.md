# Sass. Именование файлов Sass #

Все файлы именуются с маленькой буквы.

Имена cтилей не содержат тире, пробелов и пишутся только через CamelCase.

Общие правила именования sass файлов:

Структура имени: __entity + Qualification__. Т.е. название файла состоит из двух частей: __название сущности__, для которой используется файл, __уточнение к этой сущности__ (если нужно).

* _header.sass
* _typography.sass
* _asideFloatedBlock.sass

__Внимание__ Все именуется на правильном и орфографичном английском (проверяйте [словарем](https://translate.google.ru/), если не уверены в правильности). Слова в имени папки пишутся через тире (slick-slider) и с маленькой буквы.

***

# Sass. Индентация и форматирование #

Стандартная индентация для Sass — __2 пробела__ (ставьте в настройках WebStorm).

__Внимание__ Всегда сдавайте код отформатированным. Если код не отформатирован, тогда можете не сдавать его.

***

# Sass. Комментирование кода #

В Sass можно делать компиллиуремые комментарии, и не компиллируемые. Компиллируемые комменты выгружаются в итоговый .css, а не компиллируемые остаются только в .sass файле. Это образцы и их можно копировать отсюда.

1. Однострочный некомпилируемый коммент:

    ```CSS
    // Коммент
    ```

2. Однострочный компилируемый коммент:

    ```CSS
    /* Коммент
    ```

3. Многострочный компилируемый коммент такой:

    ```CSS
    /**---------------------------------------------
    * Коммент
    */
    ```

Это C-style комментарий, который выглядит как буква C.

***

# Sass. Таблица оглавления #

Таблица оглавления размещается в корневом файле, который собирает все отдельные sass файлы. Это может быть critical.sass и main-style.sass.

Оглавление состоит из списка импортируемых файлов (@import). Каждый номер оглавления — импортируемый файл.

```CSS
/**------------------------------------------------------------------
 * [Table of contents | Critical]
 *
 * 1. Typography #typography
 * 2. Variables #variables
 * 3. Colors #colors
 * 4. Mixins #mixins
 * 5. Normalize #normalize
 * 6. Grid-mixins #grid-mixins
 * 7. Responsive-utilites #responsive-utilites
 * 8. Grid #grid
 */
 ```

В начале каждого импортируемого файла делаем заглавие такого типа:

```CSS
/**
 * Colors #colors
 */
 ```

Это все сделано для того, чтобы при компиляции в собранном стиле были разделения и комменты о начале блоков стилей. Упрощает навигацию.

***

# Sass. Переменные и цвета #

## Общие переменные ##

Общие переменные вынесены в файл ```basetheme-design/css/sass/helpers/_variables.scss```. Тут лежат переменные построения сетки, кастомные переменные, которые не относятся к шрифтам и цвету.

## Переменные цвета ##

Значения и переменные цвета вынесены в отдельный файл ```basetheme-design/css/sass/helpers/_colors.scss```. Имена цветовых переменных в идеале не должны содержать отсылки к их цвету.

```CSS
$green-color: #79B316  //Так делать не надо
$regular-color: #79B316 //Так следует делать
```

## Переменные шрифтов ##

Переменные шрифтов вынесены в отдельный файл ```basetheme-design/css/sass/helpers/_typography.scss```. Имя переменной шрифта не должно отражать самого имени шрифта. Не забывайте делать подмену шрифта через бекапы sans-serif и serif, чесли кастомный шрифт не смог подключится, то чтобы браузер подтянул родственный шрифт без засечек (sans-serif) или с засечками (serif).

```CSS
$base-light-font: 'exo-2-light', sans-serif;
$second-font: 'open sans', sans-serif;
```

__Совет__ Не стоит создавать еще файлы, желательно обходится этими тремя файлами, чтобы не плодить структуру без надобности. В переменные следует записывать значения, которые будут регулярно использоваться, например транзишн и значения его тайминга, чтобы сделать все ховеры управляемыми из одного места.

## Миксины ##

В basetheme уже есть набор миксинов по умолчанию. Они здорово упрощают работу. Пользуйтесь ими.

Файл миксинов лежит: ```basetheme-design/css/sass/helpers/_mixins.scss```

* __placeholder__ — миксин для генерации стилей в плейсхолдере. Передает все значение, которые есть внутри него.

```CSS
@include placeholder
  font-style:italic
  color: white
  font-weight:100
  ```

* __cleartfix()__ — миксин обнуления обтеканий.

```CSS
@include clearfix()
```

* __absolute-center()__ — абсолютно центрирует элемент с заданными высотой и шириной.

```CSS
@include absolute-center()
```

* __x-y-center()__ — центрирует элемент по осям х и y. Размер элемента не важен, делается через transform: translate3d.

```CSS
@include x-y-center()
```

* __y-center()__ — центрирует элемент по оси y. Размер элемента не важен, делается через transform: translateY(-50%).

```CSS
@include y-center()
```

***

# Sass. БЭМ именование классов #

Мы всегда именуем классы и строим архитектуру по [БЭМ](https://ru.bem.info/).

__БЭМ__ позволяет строить архитектуру html, чтобы можно было единожды написать какой-то компонент, а затем использовать его в любом месте сайта. К этому нужно стремиться. Свободное перемещение, повторное использование.

Еще один смысл __БЭМ__ — делать разметку более прозрачной, чтобы только по одному классу можно было понять, к чему относятся стили и селекторы. Второе преимущество — это то, что каскадирование сводится к минимуму, никаких .block .inner .inner-item. .inner-item-img, а только .block__inner-img. Это позволяет парсеру браузера строить DOM дерево в меньшей степени прибегая к поискам вложенности и зависимостей.

На __БЭМе__ написаны: [Яндекс](https://ya.ru/), [HeadHunter](http://hh.ua/).

Нашей основой для именования классов является Стиль Гарри Робертса. Он визуально удобнее для восприятия, чем чистый БЭМ Яндекса.

__По БЭМу есть блоки, есть элементы блоков и есть модификаторы.__

__Блок__ — это некая конечная сущность. которую можно выделить логически. Она достаточно большая, но и достаточно самостоятельная.

__Совет__ В блоках могут быть другие блоки.

![alt text](/images/key-concepts__head_marked.png)

```HTML
<div class="tab-menu"></div> //Блок
```

__Элемент__ — это часть блока. Вне блока элемент не существует. Именуется блок через двойное подчеркивание. Например, пункт меню вне контекста блока меню не используется, значит является элементом.

![alt text](/images/key-concepts__menu-items.png)

```HTML
<ul class="tab-menu__item"></ul> //Элемент
```

__Модификатор__ — это сущность, определяющая внешний вид, состояние и поведение блока или элемента. Один и тот же блок выглядит по-разному благодаря применению модификатора.

![alt text](/images/key-concepts__site-footer-menu.png)

```HTML
<div class="tab-menu--lined"></div> //Модификатор
```

__Внимание__ Типичные ошибки использования БЭМ, которые приводят к проблемам и хаосу в коде.

```HTML
<div class="navbar__item__link"></div> //Лепим элемент элемента блока. Так нельзя, в конструкции должен быть лишь один блок и его один элемент, вот так: <div class="navbar__item-link"></div>
```

```HTML
<div class="navbar--item-link"></div> //Перепутали и написали вместо __ для элемента, -- как для модификатора. Если это элемент блока, то он отделяется двойным подчеркивание, а не тире.
```

***

# Sass. Общая архитектура #

Наш вариант разделения стилей таков:

* __base64-fonts.css__ шрифты, записываемые в localStorage
* __critical.css__, который содержит: normalize, сетку, типографику, основные стили для дизайна, которые требуются для корректного отображения сайта.
* __main-style.css__ — здесь записаны все sass компоненты.
Отделение шрифтов в base64 требуется для того, чтобы при первой загрузке скрипт загрузил их в localStorage. Тогда при повторной загрузке шрифты будут грузится из localStorage, что ускорит повторную загрузку на 30%.

Загрузочный critical.css подгружается в \<head\> инлайново в теге \<style\> через Molt. Конечный main-style.css стиль подгружается в конце загрузки страницы, через скрипт.

__Внимание__ Не забывайте ставить в \<head\> стили в \<noscript\> .

***

# Sass. Critical css #

На сегодняшний день очень много людей пользуются мобильным интернетом. В 2015 году в Украине стартовал 3G интернет, что значит, что в 2016+ годах мы получим большой прирост мобильных юзеров. Это означает что теперь нам следует большое внимание уделять не только десктопу, но именно мобильным отображениям.

Философия critical.css основана на рекомендациях Google. Они рекомендовали отделить необходимые стили страницы, чтобы инлайново загружать их прямо в <head> страницы. Таким образом мы сократим запросы к серверу, ведь эти стили загружаются на сервере, выдаваясь вместе со страницей, а не требуя отдельного запроса к серверу за файлом стилей. Преимущество налицо.

Логика разделения в том, чтобы сюда записать только самый важный рендеринговый стиль, который позволит юзеру увидеть страницу презентабельной и как можно быстрее.

Цель оптимизации - минимизировать время визуализации страниц. Этого можно добиться, меняя порядок загрузки ресурсов. Помните, что чем меньше времени пользователь проводит перед пустым экраном, тем больше степень его вовлеченности. Кроме того, оптимизация позволяет увеличить число просмотров и улучшить конверсию.

## Метрики ##

В мануале Google [Анализ процесса визуализации](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp) , описан обобщенный процесс анализа метрик. На сайте HTML5Rocks описана большая статья о том, [как работает браузер](http://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/).

Есть 3 этапа загрузки страницы, которые являются вехами: __First paint__, __DOMContentLoaded__ и __Load Event__.

Событие __First paint__ — момент, когда на странице отображается первый графисеский элемент (например чаcть хедера). То есть барузер уже все распарсил, построил DOM, CSSOM и начинает переводить все в пиксели на экран. Чтобы визуализировать эту страницу, браузер должен отправить запрос на сервер, скачать HTML-документ, проанализировать его, создать модель DOM и, наконец, вывести страницу на экран.
Браузер может создавать модель визуализации и выводить страницу на экран, не дожидаясь загрузки всех элементов, потому что не все ресурсы необходимы для первоочередной визуализации. Первоочередной процесс визуализации затрагивает только HTML-, CSS и JavaScript-файлы.

Событие __DOMContentLoaded__ — парсер всей страницы полностью построил DOM из HTML узлов и выполнил все синхронно подключенные скрипты.

Событие __Load Event__ — когда вся страница, включая изображения полностью загрузилась.

__Ключевые метрики:__

## Порядок работы ##

1. Сначала все стили пишутся в обычных компонентах (parts/404.sass, components/footer.sass и т.д.). Все пишется с ховерами, со всеми нюансами. По сути это полноценный стиль, который собирается в main-style.css.
2. После того, как верстка закончена, фронтендер приступает к разделению. Он просматривает постранично все брейкпоинты и определяет, какие стили нужно вынести из main-style.css в critical.css.
Сюда выносятся стили, которые позволяют сохранить каркас страницы, ее основные дизайнерские и функциональные моменты (цвет ссылок, размеры типографики, хедер и футер, размеры картинок, ключевые отступы).
3. Итоговый __critical.css__ содержит:
    * base/normalize
    * helpers/typography
    * helpers/variables
    * helpers/colors
    * helpers/mixins
    * layout/grid-mixins
    * layout/responsive-utilites
    * layout/grid
    * critical/critical-style

__Важно__ Каждый фронтендер студии должен пройти курс: [Website Performance Optimization](https://www.udacity.com/course/website-performance-optimization--ud884).

## Какие свойства нужно вынести в critical.sass ##

Главный момент — мы должны выдать юзеру читабельный текст, который имеет размер как в макете, и несет в себе зачатки дизайна. Никакого горизонтального скролла быть не должно. При загрузке страница не должна глобально перестраиваться, когда основные стили будут подгружены.

__Сначала измерьте показатели — потом оптимизируйте по необходимости.__

* Размер шрифта страницы, заголовков, всего ключевого текста.
* Цвет ссылок по умолчанию на всем сайте (заменить противный синий дефолтный), убрать подчеркивание у ссылок, если нужно.
* Полноценный стиль хедера, без ховеров и выпадающих активностей.
* Размеры картинок - max-width: 100%, чтобы они не ломали сетку (должно быть по дефолту в библиотеке).
* Скрыть блоки, которые не должны быть показаны там, где не надо (в брейкпоинтах в соответствии с макетом).
* Проверить все брейкпоинты, найти какие секции и дивы ломают сетку, и устраницть проблемы. Ключевое — чтобы не было горизонтального скролла страницы.
* Жизненно необходимые плагины (слайдеры и прочее, что может ломать сетку).

## Сайты с critical.css подходом. ##

http://dbushell.com/2015/02/19/critical-css-and-performance/

## Ссылки для чтения ##

http://www.smashingmagazine.com/2015/08/understanding-critical-css/ — обзор плагина critical.css для Grunt.

https://css-tricks.com/authoring-critical-fold-css/ — Css-tricks обзор технологии.